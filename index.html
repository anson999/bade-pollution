<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>桃園八德大興里空氣異味監測與分析報告</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        /* 使用 Inter 字體 */
        body { font-family: 'Inter', sans-serif; }
        /* 確保圖表容器有高度 */
        .chart-container { height: 400px; }
        @media (max-width: 768px) {
            .chart-container { height: 300px; }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-extrabold text-blue-700 tracking-tight mb-2">
                大興里空氣異味監測與分析報告
            </h1>
            <p id="last-updated" class="text-sm text-gray-500">
                數據將在背景中每 10 分鐘自動更新。
            </p>
        </header>
        
        <div id="error-message" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4" role="alert">
            <strong class="font-bold">資料載入錯誤：</strong>
            <span id="error-text" class="block sm:inline"></span>
        </div>

        <section class="bg-white p-6 rounded-xl shadow-lg mb-8 transition-shadow duration-300 hover:shadow-xl">
            <h2 class="text-xl font-semibold text-gray-700 mb-4 border-b pb-2">
                篩選條件
            </h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div>
                    <label for="location-filter" class="block text-sm font-medium text-gray-700 mb-1">
                        發生位置
                    </label>
                    <select id="location-filter" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150">
                        <option value="all">所有地點</option>
                        </select>
                </div>

                <div>
                    <label for="concentration-filter" class="block text-sm font-medium text-gray-700 mb-1">
                        氣味濃度
                    </label>
                    <select id="concentration-filter" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150">
                        <option value="all">所有濃度</option>
                        <option value="重度">重度 (Heavy)</option>
                        <option value="中度">中度 (Medium)</option>
                        <option value="輕度">輕度 (Light)</option>
                    </select>
                </div>

                <div class="flex items-end">
                    <button id="reset-button" class="w-full bg-indigo-500 text-white p-2 rounded-lg font-medium hover:bg-indigo-600 transition duration-200 shadow-md">
                        重設篩選
                    </button>
                </div>
            </div>
        </section>

        <section class="grid grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
            <div class="bg-white p-5 rounded-xl shadow-md border-b-4 border-blue-500">
                <p class="text-sm font-medium text-gray-500">總回報筆數</p>
                <p id="kpi-total" class="text-3xl font-bold text-gray-900 mt-1">0</p>
            </div>
            <div class="bg-white p-5 rounded-xl shadow-md border-b-4 border-green-500">
                <p class="text-sm font-medium text-gray-500">發生異味天數</p>
                <p id="kpi-days" class="text-3xl font-bold text-gray-900 mt-1">0</p>
            </div>
            <div class="bg-white p-5 rounded-xl shadow-md border-b-4 border-red-500">
                <p class="text-sm font-medium text-gray-500">重度回報比例</p>
                <p id="kpi-heavy-ratio" class="text-3xl font-bold text-gray-900 mt-1">0%</p>
            </div>
            <div class="bg-white p-5 rounded-xl shadow-md border-b-4 border-yellow-500">
                <p class="text-sm font-medium text-gray-500">最常發生時段</p>
                <p id="kpi-peak-time" class="text-2xl font-bold text-gray-900 mt-2">--</p>
            </div>
        </section>

        <section class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <div class="bg-white p-6 rounded-xl shadow-md transition-shadow duration-300 hover:shadow-xl">
                <h3 class="text-lg font-semibold text-gray-700 mb-4">污染類型佔比</h3>
                <div class="chart-container">
                    <canvas id="typeChart"></canvas>
                </div>
            </div>

            <div class="bg-white p-6 rounded-xl shadow-md transition-shadow duration-300 hover:shadow-xl">
                <h3 class="text-lg font-semibold text-gray-700 mb-4">地點與濃度交叉分析</h3>
                <div class="chart-container">
                    <canvas id="locationConcentrationChart"></canvas>
                </div>
            </div>

            <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-md transition-shadow duration-300 hover:shadow-xl">
                <h3 class="text-lg font-semibold text-gray-700 mb-4">異味發生熱點時段 (12小時制)</h3>
                <div class="chart-container h-96">
                    <canvas id="timeChart"></canvas>
                </div>
            </div>

            <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-md transition-shadow duration-300 hover:shadow-xl">
                <h3 class="text-lg font-semibold text-gray-700 mb-4">近七日回報紀錄趨勢</h3>
                <div class="chart-container h-96">
                    <canvas id="weeklyTrendChart"></canvas>
                </div>
            </div>
            
            <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-md transition-shadow duration-300 hover:shadow-xl">
                <h3 class="text-lg font-semibold text-gray-700 mb-4">近一個月回報紀錄趨勢</h3>
                <div class="chart-container h-96">
                    <canvas id="monthlyTrendChart"></canvas>
                </div>
            </div>
        </section>
    </div>

    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex justify-center items-center z-50">
        <p class="text-white text-xl font-semibold">
            <svg class="animate-spin -ml-1 mr-3 h-8 w-8 text-white inline-block" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            正在載入並分析資料...
        </p>
    </div>


    <script>
        // 設定 CSV 資料來源 URL
        const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSU08cMkQD3qG0_wn4GxHH9Ebo8J3cyDB7oOk1GOjEVi55aB-2_Ks81gYKKoR86I4Ey2oGGX-ZFF3JR/pub?output=csv';

        let rawData = []; // 儲存原始資料
        let filteredData = []; // 儲存篩選後的資料
        let charts = {}; // 儲存 Chart.js 實例

        // DOM 元素引用
        const locationFilter = document.getElementById('location-filter');
        const concentrationFilter = document.getElementById('concentration-filter');
        const resetButton = document.getElementById('reset-button');
        const loadingOverlay = document.getElementById('loading-overlay');
        const lastUpdated = document.getElementById('last-updated');
        const errorMessage = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');
        
        // 錯誤處理函數，顯示自訂錯誤訊息
        const displayError = (message) => {
            errorText.textContent = message;
            errorMessage.classList.remove('hidden');
            // 讓錯誤訊息在 10 秒後自動消失
            setTimeout(() => {
                errorMessage.classList.add('hidden');
            }, 10000);
        };
        
        // 清除錯誤訊息
        const clearError = () => {
            errorMessage.classList.add('hidden');
            errorText.textContent = '';
        };

        // Helper to format Date object to YYYY/MM/DD string for comparison (consistent key format)
        const formatDateKey = (date) => {
            const y = date.getFullYear();
            const m = (date.getMonth() + 1).toString().padStart(2, '0');
            const d = date.getDate().toString().padStart(2, '0');
            return `${y}/${m}/${d}`; 
        };
        
        // 日期字串標準化函數：將各種格式的日期字串轉換為 YYYY/MM/DD 格式
        const normalizeDate = (dateString) => {
            if (!dateString) return null;
            
            // 1. 移除時間部分（如果存在），只保留日期
            let datePart = dateString.split(' ')[0];
            
            // 2. 嘗試解析 M/D/YYYY, YYYY/M/D, 或 M-D-YYYY 等格式
            const parts = datePart.split(/[-\/]/).map(p => p.trim());
            
            if (parts.length === 3) {
                let year, month, day;
                
                // 簡易啟發式判斷：如果第一部分是四位數，則假設為 YYYY/MM/DD
                if (parts[0].length === 4) { 
                    year = parts[0];
                    month = parts[1];
                    day = parts[2];
                } else if (parts[2].length === 4) { // 假設為 MM/DD/YYYY 或 DD/MM/YYYY
                    year = parts[2];
                    month = parts[0]; // 假設月份是第一部分
                    day = parts[1];
                } else {
                    return dateString; // 無法可靠解析，返回原始字串
                }

                // 處理月份和日期，確保兩位數
                return `${year}/${month.padStart(2, '0')}/${day.padStart(2, '0')}`;
            }

            return dateString; // 解析失敗，返回原始字串
        };

        // 時間轉換函數：將 12 小時制 (如 3:00 PM) 或 24 小時制 (如 14:00) 轉換為 0-23 的小時整數
        const convertTo24Hour = (timeString) => {
            if (!timeString) return NaN;
            
            const trimmedTime = timeString.toUpperCase().trim();
            
            // 嘗試匹配 12-hour 格式: H:MM AM/PM, H:MM:SS AM/PM
            const match12 = trimmedTime.match(/(\d{1,2}):\d{2}(:\d{2})?\s*(AM|PM)/);
            
            if (match12) {
                let hour = parseInt(match12[1], 10);
                const ampm = match12[3];

                if (ampm === 'PM' && hour !== 12) {
                    hour += 12; // 1 PM -> 13, 11 PM -> 23
                } else if (ampm === 'AM' && hour === 12) {
                    hour = 0; // 12 AM (midnight) -> 0
                }
                return hour; // 0-23
            } 
            
            // 嘗試匹配 24-hour 格式: HH:MM, HH:MM:SS (例如 14:30)
            const match24 = trimmedTime.match(/(\d{1,2}):\d{2}/);
            
            if (match24) {
                const hour = parseInt(match24[1], 10);
                if (hour >= 0 && hour <= 23) {
                    return hour;
                }
            }
            
            return NaN; // 解析失敗
        };


        // --- 資料獲取與解析 (使用 PapaParse) ---
        const fetchData = async () => {
            clearError();
            loadingOverlay.classList.remove('hidden');
            try {
                const response = await fetch(CSV_URL);
                if (!response.ok) throw new Error('無法載入 CSV 資料。請檢查網路連線或連結是否有效。');

                const csvText = await response.text();
                
                return new Promise((resolve, reject) => {
                    Papa.parse(csvText, {
                        header: true,
                        skipEmptyLines: true,
                        // 確保 CSV 標題被 trim() 處理，確保欄位名稱匹配準確
                        transformHeader: function(header) {
                            return header.trim();
                        },
                        complete: function(results) {
                            
                            const data = results.data;
                            const fields = results.meta.fields || [];

                            // Helper function to find the actual key in the row data based on a partial match (e.g., '發生日期')
                            const findKey = (partialName) => fields.find(f => f && f.includes(partialName));

                            // 識別關鍵欄位 (動態匹配，即使有隱藏字元也能找到)
                            const dateKey = findKey('發生日期');
                            const timeKey = findKey('發生時間');
                            const locationKey = findKey('空氣異味確切發生位置');
                            const concentrationKey = findKey('氣味濃度');
                            const typeKey = findKey('空氣異味類型');
                            
                            // 檢查最關鍵的欄位是否找到
                            if (!dateKey || !locationKey) {
                                console.error("Critical headers not found:", fields);
                                displayError(`CSV 檔案的關鍵欄位 ('發生日期' 或 '空氣異味確切發生位置') 不存在或無法辨識。`);
                                resolve([]);
                                return; 
                            }

                            rawData = data
                                .map(row => {
                                    // 使用動態找到的 key 來提取數據並清除前後空格
                                    const rawDate = row[dateKey] ? String(row[dateKey]).trim() : null;
                                    const date = normalizeDate(rawDate); // 標準化日期格式
                                    const time = row[timeKey] ? String(row[timeKey]).trim() : null;
                                    const location = row[locationKey] ? String(row[locationKey]).trim() : null;
                                    const concentration = row[concentrationKey] ? String(row[concentrationKey]).trim() : null;
                                    const type = row[typeKey] ? String(row[typeKey]).trim() : null;
                                    
                                    // 在此處預先轉換為 24 小時制的小時數
                                    const hour24 = convertTo24Hour(time);

                                    return { date, time, location, concentration, type, hour24 };
                                })
                                .filter(row => row.date && row.location && !isNaN(row.hour24)); // 確保關鍵欄位和 hour24 有效
                            
                            if (rawData.length === 0) {
                                displayError("資料已成功讀取，但未包含有效的回報數據。請檢查試算表內容是否至少有一筆完整的日期、位置和時間資訊。");
                            }

                            resolve(rawData);
                        },
                        error: function(error) {
                            reject(error);
                        }
                    });
                });
            } catch (error) {
                console.error("資料獲取或解析錯誤:", error);
                displayError(`無法載入或解析數據：${error.message} (錯誤碼: ${error.message.includes('Failed to fetch') ? '網路/CORS' : '解析失敗'})`);
                return [];
            } finally {
                loadingOverlay.classList.add('hidden');
                updateTimestamp();
            }
        };

        const updateTimestamp = () => {
            const now = new Date();
            const timeString = now.toLocaleTimeString('zh-TW', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            lastUpdated.textContent = `上次更新時間: ${timeString}。數據將在背景中每 10 分鐘自動更新。`;
        }

        // --- 數據處理與分析函數 ---
        const applyFilters = () => {
            const selectedLocation = locationFilter.value;
            const selectedConcentration = concentrationFilter.value;

            filteredData = rawData.filter(row => {
                const locationMatch = selectedLocation === 'all' || row.location === selectedLocation;
                const concentrationMatch = selectedConcentration === 'all' || row.concentration === selectedConcentration;
                return locationMatch && concentrationMatch;
            });

            renderDashboard(filteredData);
        };

        // --- KPI 計算函數 ---
        const calculateKPIs = (data) => {
            const totalCount = data.length;
            const uniqueDates = new Set(data.map(row => row.date));
            const heavyReports = data.filter(row => row.concentration === '重度').length;

            const heavyRatio = totalCount > 0 ? ((heavyReports / totalCount) * 100).toFixed(1) : 0;

            // 12小時制時間格式化 helper
            const hourTo12hDisplay = (h24) => {
                const hour = parseInt(h24, 10);
                let hour12;
                let suffix;

                if (hour === 0) {
                    hour12 = 12; // 0點是 12 AM
                    suffix = ' AM';
                } else if (hour < 12) {
                    hour12 = hour;
                    suffix = ' AM';
                } else if (hour === 12) {
                    hour12 = 12;
                    suffix = ' PM';
                } else { // hour > 12
                    hour12 = hour - 12;
                    suffix = ' PM';
                }
                return `${hour12.toString()}${suffix}`;
            };


            // 計算最常發生時段 (按小時)
            let peakHour = '--'; // 預設值
            let maxCount = 0;
            
            if (totalCount > 0) {
                const hourCounts = data.reduce((acc, row) => {
                    // 直接使用預先計算好的 24 小時制小時數
                    const hour = row.hour24;
                    
                    if (!isNaN(hour)) {
                         acc[hour] = (acc[hour] || 0) + 1;
                    }
                    return acc;
                }, {});

                // 找出計數最多的時段
                let peakHour24 = null;
                Object.keys(hourCounts).forEach(hour => {
                    const count = hourCounts[hour];
                    if (count > maxCount) {
                        maxCount = count;
                        peakHour24 = hour; // 記住 24 小時制的起始小時
                    }
                });
                
                // 如果找到熱點，只顯示起始時間 + "(1小時)"
                if (peakHour24 !== null) {
                    peakHour = `${hourTo12hDisplay(peakHour24)} (1小時)`;
                }
            }
            
            // 寫入 DOM
            document.getElementById('kpi-total').textContent = totalCount.toLocaleString();
            document.getElementById('kpi-days').textContent = uniqueDates.size.toLocaleString();
            document.getElementById('kpi-heavy-ratio').textContent = `${heavyRatio}%`;
            document.getElementById('kpi-peak-time').textContent = peakHour;
        };

        // --- 圖表繪製函數 ---

        const initializeChart = (chartId, type, config) => {
            if (charts[chartId]) {
                charts[chartId].destroy();
            }
            const ctx = document.getElementById(chartId).getContext('2d');
            charts[chartId] = new Chart(ctx, { type, ...config });
        };

        const renderTypeChart = (data) => {
            const typeCounts = data.reduce((acc, row) => { 
                const type = row.type || '未知異味';
                acc[type] = (acc[type] || 0) + 1;
                return acc;
            }, {});

            const labels = Object.keys(typeCounts);
            const counts = Object.values(typeCounts);

            initializeChart('typeChart', 'pie', {
                data: {
                    labels: labels,
                    datasets: [{
                        data: counts,
                        backgroundColor: ['#3b82f6', '#ef4444', '#f59e0b', '#10b981', '#6366f1', '#f97316'],
                        hoverOffset: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: false }
                    }
                }
            });
        };

        const renderTimeChart = (data) => {
            const hourCounts = Array(24).fill(0); // 0-23 小時
            
            // 優化 12 小時制標籤生成邏輯
            const hours = Array.from({ length: 24 }, (_, i) => {
                const hour = i;
                let hour12;
                let suffix;

                if (hour === 0) {
                    hour12 = 12;
                    suffix = ' AM';
                } else if (hour < 12) {
                    hour12 = hour;
                    suffix = ' AM';
                } else if (hour === 12) {
                    hour12 = 12;
                    suffix = ' PM';
                } else { // hour > 12
                    hour12 = hour - 12;
                    suffix = ' PM';
                }
                return `${hour12}${suffix}`;
            });

            data.forEach(row => {
                // 直接使用預先計算好的 24 小時制小時數
                const hour = row.hour24;
                
                if (!isNaN(hour) && hour >= 0 && hour <= 23) {
                    hourCounts[hour]++;
                }
            });

            initializeChart('timeChart', 'bar', {
                data: {
                    labels: hours,
                    datasets: [{
                        label: '回報筆數',
                        data: hourCounts,
                        backgroundColor: '#4f46e5',
                        borderColor: '#3730a3',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: '回報筆數' } },
                        x: { 
                            title: { display: true, text: '時間 (12小時制)' },
                            // 調整刻度，避免標籤過於擁擠
                            ticks: {
                                autoSkip: true,
                                maxTicksLimit: 12 // 最多顯示 12 個刻度
                            }
                        } 
                    },
                    plugins: { legend: { display: false } }
                }
            });
        };

        const renderLocationConcentrationChart = (data) => {
            const locations = [...new Set(data.map(d => d.location).filter(l => l))].sort();
            const concentrations = ['輕度', '中度', '重度']; // 預設排序

            const counts = locations.reduce((acc, loc) => {
                acc[loc] = concentrations.reduce((cAcc, conc) => {
                    cAcc[conc] = 0;
                    return cAcc;
                }, {});
                return acc;
            }, {});

            data.forEach(row => {
                if (row.location && row.concentration && concentrations.includes(row.concentration)) {
                    counts[row.location][row.concentration]++;
                }
            });

            const datasets = concentrations.map((conc, index) => {
                const colorMap = { '輕度': '#10b981', '中度': '#f59e0b', '重度': '#ef4444' };
                return {
                    label: conc,
                    data: locations.map(loc => counts[loc][conc]),
                    backgroundColor: colorMap[conc] || '#9ca3af',
                };
            });

            initializeChart('locationConcentrationChart', 'bar', {
                data: {
                    labels: locations,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { stacked: true, title: { display: true, text: '發生位置' } },
                        y: { stacked: true, beginAtZero: true, title: { display: true, text: '回報筆數' } }
                    },
                    plugins: { legend: { position: 'top' } }
                }
            });
        };

        // 近七日回報紀錄趨勢 (折線圖)
        const renderWeeklyTrendChart = (data) => {
            // 1. 確定過去 7 天的日期 (包含今天)
            const today = new Date();
            today.setHours(0, 0, 0, 0); // 標準化到午夜
            
            let dateLabels = []; // 標籤 (例如: "11/05")
            let dateKeys = [];   // 資料比對鍵 (例如: "2025/11/05")
            
            // 產生過去 7 天的日期列表 (從 6 天前到今天)
            for (let i = 6; i >= 0; i--) {
                const d = new Date(today);
                d.setDate(today.getDate() - i);
                
                // 產生 Chart 標籤 (月/日)
                const label = `${(d.getMonth() + 1).toString().padStart(2, '0')}/${d.getDate().toString().padStart(2, '0')}`;
                dateLabels.push(label);
                
                // 產生資料比對鍵 (年/月/日) - 與 normalized data 格式一致
                dateKeys.push(formatDateKey(d));
            }
            
            // 2. 計算過去 7 天的回報筆數
            const counts = dateKeys.map(key => {
                return data.filter(row => row.date === key).length; 
            });

            // 3. 繪製折線圖
            initializeChart('weeklyTrendChart', 'line', {
                data: {
                    labels: dateLabels,
                    datasets: [{
                        label: '回報筆數',
                        data: counts,
                        backgroundColor: 'rgba(59, 130, 246, 0.5)', // 藍色透明背景
                        borderColor: '#3b82f6',
                        borderWidth: 3,
                        tension: 0.3, // 曲線平滑
                        fill: true,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: '回報筆數' },
                            // 確保 Y 軸刻度是整數
                            ticks: {
                                precision: 0 
                            }
                        },
                        x: {
                            title: { display: true, text: '日期' }
                        }
                    },
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: false }
                    }
                }
            });
        };

        // 近一個月 (30天) 回報紀錄趨勢 (折線圖)
        const renderMonthlyTrendChart = (data) => {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            let dateLabels = []; // 標籤 (月/日)
            let dateKeys = [];   // 資料比對鍵 (年/月/日)
            
            // 產生過去 30 天的日期列表 (從 29 天前到今天)
            for (let i = 29; i >= 0; i--) {
                const d = new Date(today);
                d.setDate(today.getDate() - i);
                
                const label = `${(d.getMonth() + 1).toString().padStart(2, '0')}/${d.getDate().toString().padStart(2, '0')}`;
                dateLabels.push(label);
                
                dateKeys.push(formatDateKey(d));
            }
            
            // 計算過去 30 天的回報筆數
            const counts = dateKeys.map(key => {
                return data.filter(row => row.date === key).length; 
            });

            // 繪製折線圖
            initializeChart('monthlyTrendChart', 'line', {
                data: {
                    labels: dateLabels,
                    datasets: [{
                        label: '回報筆數',
                        data: counts,
                        backgroundColor: 'rgba(16, 185, 129, 0.5)', // 綠色透明背景
                        borderColor: '#10b981',
                        borderWidth: 3,
                        tension: 0.3,
                        fill: true,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: '回報筆數' },
                            ticks: { precision: 0 }
                        },
                        x: {
                            title: { display: true, text: '日期' },
                            // 調整刻度以避免 30 個標籤過於擁擠，大約每 5 天顯示一次
                            ticks: {
                                autoSkip: true,
                                maxRotation: 0,
                                minRotation: 0,
                                maxTicksLimit: 7
                            }
                        }
                    },
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: false }
                    }
                }
            });
        };


        // --- 主渲染函數 ---
        const renderDashboard = (data) => {
            calculateKPIs(data);
            renderTypeChart(data);
            renderTimeChart(data);
            renderLocationConcentrationChart(data);
            renderWeeklyTrendChart(data); 
            renderMonthlyTrendChart(data); 
        };

        // --- 初始化與事件監聽 ---
        const setupFilters = () => {
            // 填充地點篩選器
            const locations = [...new Set(rawData.map(row => row.location).filter(l => l))].sort();
            
            // 清空現有選項，保留 '所有地點'
            while (locationFilter.options.length > 1) {
                locationFilter.remove(1);
            }
            
            locations.forEach(location => {
                const option = document.createElement('option');
                option.value = location;
                option.textContent = location;
                locationFilter.appendChild(option);
            });

            // 註冊事件監聽器
            locationFilter.addEventListener('change', applyFilters);
            concentrationFilter.addEventListener('change', applyFilters);
            resetButton.addEventListener('click', () => {
                locationFilter.value = 'all';
                concentrationFilter.value = 'all';
                applyFilters();
            });
        };

        // 啟動函數
        const init = async () => {
            await fetchData();
            setupFilters();
            applyFilters(); // 初次渲染
            
            // 設定每 10 分鐘自動更新 (600,000 毫秒)
            setInterval(async () => {
                console.log("自動更新中...");
                await fetchData();
                // 重新設置篩選器選項以防有新地點出現
                setupFilters(); 
                // 重新應用篩選器，並渲染儀表板
                applyFilters(); 
            }, 600000); 
        };

        window.onload = init;
    </script>
</body>
</html>
